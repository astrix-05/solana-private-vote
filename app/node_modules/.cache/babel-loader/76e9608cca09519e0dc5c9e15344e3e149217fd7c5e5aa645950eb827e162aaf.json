{"ast":null,"code":"import { Buffer } from 'buffer';\nimport { EventEmitter } from 'eventemitter3';\n\n// node_modules/esbuild-plugin-polyfill-node/polyfills/buffer.js\nvar WebSocketBrowserImpl = class extends EventEmitter {\n  socket;\n  /** Instantiate a WebSocket class\n  * @constructor\n  * @param {String} address - url to a websocket server\n  * @param {(Object)} options - websocket options\n  * @param {(String|Array)} protocols - a list of protocols\n  * @return {WebSocketBrowserImpl} - returns a WebSocket instance\n  */\n  constructor(address, options, protocols) {\n    super();\n    this.socket = new window.WebSocket(address, protocols);\n    this.socket.onopen = () => this.emit(\"open\");\n    this.socket.onmessage = event => this.emit(\"message\", event.data);\n    this.socket.onerror = error => this.emit(\"error\", error);\n    this.socket.onclose = event => {\n      this.emit(\"close\", event.code, event.reason);\n    };\n  }\n  /**\n  * Sends data through a websocket connection\n  * @method\n  * @param {(String|Object)} data - data to be sent via websocket\n  * @param {Object} optionsOrCallback - ws options\n  * @param {Function} callback - a callback called once the data is sent\n  * @return {Undefined}\n  */\n  send(data, optionsOrCallback, callback) {\n    const cb = callback || optionsOrCallback;\n    try {\n      this.socket.send(data);\n      cb();\n    } catch (error) {\n      cb(error);\n    }\n  }\n  /**\n  * Closes an underlying socket\n  * @method\n  * @param {Number} code - status code explaining why the connection is being closed\n  * @param {String} reason - a description why the connection is closing\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  close(code, reason) {\n    this.socket.close(code, reason);\n  }\n  addEventListener(type, listener, options) {\n    this.socket.addEventListener(type, listener, options);\n  }\n};\nfunction WebSocket(address, options) {\n  return new WebSocketBrowserImpl(address, options);\n}\n\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n  encode(value) {\n    return JSON.stringify(value);\n  }\n  decode(value) {\n    return JSON.parse(value);\n  }\n};\n\n// src/lib/client.ts\nvar CommonClient = class extends EventEmitter {\n  address;\n  rpc_id;\n  queue;\n  options;\n  autoconnect;\n  ready;\n  reconnect;\n  reconnect_timer_id;\n  reconnect_interval;\n  max_reconnects;\n  rest_options;\n  current_reconnects;\n  generate_request_id;\n  socket;\n  webSocketFactory;\n  dataPack;\n  /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */\n  constructor(webSocketFactory, address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5,\n    ...rest_options\n  } = {}, generate_request_id, dataPack) {\n    super();\n    this.webSocketFactory = webSocketFactory;\n    this.queue = {};\n    this.rpc_id = 0;\n    this.address = address;\n    this.autoconnect = autoconnect;\n    this.ready = false;\n    this.reconnect = reconnect;\n    this.reconnect_timer_id = void 0;\n    this.reconnect_interval = reconnect_interval;\n    this.max_reconnects = max_reconnects;\n    this.rest_options = rest_options;\n    this.current_reconnects = 0;\n    this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n    if (!dataPack) this.dataPack = new DefaultDataPack();else this.dataPack = dataPack;\n    if (this.autoconnect) this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */\n  connect() {\n    if (this.socket) return;\n    this._connect(this.address, {\n      autoconnect: this.autoconnect,\n      reconnect: this.reconnect,\n      reconnect_interval: this.reconnect_interval,\n      max_reconnects: this.max_reconnects,\n      ...this.rest_options\n    });\n  }\n  /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */\n  call(method, params, timeout, ws_opts) {\n    if (!ws_opts && \"object\" === typeof timeout) {\n      ws_opts = timeout;\n      timeout = null;\n    }\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const rpc_id = this.generate_request_id(method, params);\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params: params || void 0,\n        id: rpc_id\n      };\n      this.socket.send(this.dataPack.encode(message), ws_opts, error => {\n        if (error) return reject(error);\n        this.queue[rpc_id] = {\n          promise: [resolve, reject]\n        };\n        if (timeout) {\n          this.queue[rpc_id].timeout = setTimeout(() => {\n            delete this.queue[rpc_id];\n            reject(new Error(\"reply timeout\"));\n          }, timeout);\n        }\n      });\n    });\n  }\n  /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */\n  async login(params) {\n    const resp = await this.call(\"rpc.login\", params);\n    if (!resp) throw new Error(\"authentication failed\");\n    return resp;\n  }\n  /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */\n  async listMethods() {\n    return await this.call(\"__listMethods\");\n  }\n  /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */\n  notify(method, params) {\n    return new Promise((resolve, reject) => {\n      if (!this.ready) return reject(new Error(\"socket not ready\"));\n      const message = {\n        jsonrpc: \"2.0\",\n        method,\n        params\n      };\n      this.socket.send(this.dataPack.encode(message), error => {\n        if (error) return reject(error);\n        resolve();\n      });\n    });\n  }\n  /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async subscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.on\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n    return result;\n  }\n  /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */\n  async unsubscribe(event) {\n    if (typeof event === \"string\") event = [event];\n    const result = await this.call(\"rpc.off\", event);\n    if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n    return result;\n  }\n  /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */\n  close(code, data) {\n    if (this.socket) this.socket.close(code || 1e3, data);\n  }\n  /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */\n  setAutoReconnect(reconnect) {\n    this.reconnect = reconnect;\n  }\n  /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */\n  setReconnectInterval(interval) {\n    this.reconnect_interval = interval;\n  }\n  /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */\n  setMaxReconnects(max_reconnects) {\n    this.max_reconnects = max_reconnects;\n  }\n  /**\n  * Get the current number of reconnection attempts made.\n  * @method\n  * @return {Number} current reconnection attempts\n  */\n  getCurrentReconnects() {\n    return this.current_reconnects;\n  }\n  /**\n  * Get the maximum number of reconnection attempts.\n  * @method\n  * @return {Number} maximum reconnection attempts\n  */\n  getMaxReconnects() {\n    return this.max_reconnects;\n  }\n  /**\n  * Check if the client is currently attempting to reconnect.\n  * @method\n  * @return {Boolean} true if reconnection is in progress\n  */\n  isReconnecting() {\n    return this.reconnect_timer_id !== void 0;\n  }\n  /**\n  * Check if the client will attempt to reconnect on the next close event.\n  * @method\n  * @return {Boolean} true if reconnection will be attempted\n  */\n  willReconnect() {\n    return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);\n  }\n  /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */\n  _connect(address, options) {\n    clearTimeout(this.reconnect_timer_id);\n    this.socket = this.webSocketFactory(address, options);\n    this.socket.addEventListener(\"open\", () => {\n      this.ready = true;\n      this.emit(\"open\");\n      this.current_reconnects = 0;\n    });\n    this.socket.addEventListener(\"message\", ({\n      data: message\n    }) => {\n      if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n      try {\n        message = this.dataPack.decode(message);\n      } catch (error) {\n        return;\n      }\n      if (message.notification && this.listeners(message.notification).length) {\n        if (!Object.keys(message.params).length) return this.emit(message.notification);\n        const args = [message.notification];\n        if (message.params.constructor === Object) args.push(message.params);else for (let i = 0; i < message.params.length; i++) args.push(message.params[i]);\n        return Promise.resolve().then(() => {\n          this.emit.apply(this, args);\n        });\n      }\n      if (!this.queue[message.id]) {\n        if (message.method) {\n          return Promise.resolve().then(() => {\n            this.emit(message.method, message?.params);\n          });\n        }\n        return;\n      }\n      if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either \"result\" or \"error\", but not both.'));\n      if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n      if (message.error) this.queue[message.id].promise[1](message.error);else this.queue[message.id].promise[0](message.result);\n      delete this.queue[message.id];\n    });\n    this.socket.addEventListener(\"error\", error => this.emit(\"error\", error));\n    this.socket.addEventListener(\"close\", ({\n      code,\n      reason\n    }) => {\n      if (this.ready) setTimeout(() => this.emit(\"close\", code, reason), 0);\n      this.ready = false;\n      this.socket = void 0;\n      if (code === 1e3) return;\n      this.current_reconnects++;\n      if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {\n        setTimeout(() => this.emit(\"max_reconnects_reached\", code, reason), 1);\n      }\n    });\n  }\n};\n\n// src/index.browser.ts\nvar Client = class extends CommonClient {\n  constructor(address = \"ws://localhost:8080\", {\n    autoconnect = true,\n    reconnect = true,\n    reconnect_interval = 1e3,\n    max_reconnects = 5\n  } = {}, generate_request_id) {\n    super(WebSocket, address, {\n      autoconnect,\n      reconnect,\n      reconnect_interval,\n      max_reconnects\n    }, generate_request_id);\n  }\n};\nexport { Client, CommonClient, DefaultDataPack, WebSocket };\n\n//# sourceMappingURL=index.browser.mjs.map","map":{"version":3,"names":["WebSocketBrowserImpl","EventEmitter","socket","constructor","address","options","protocols","window","WebSocket","onopen","emit","onmessage","event","data","onerror","error","onclose","code","reason","send","optionsOrCallback","callback","cb","close","addEventListener","type","listener","DefaultDataPack","encode","value","JSON","stringify","decode","parse","CommonClient","rpc_id","queue","autoconnect","ready","reconnect","reconnect_timer_id","reconnect_interval","max_reconnects","rest_options","current_reconnects","generate_request_id","webSocketFactory","dataPack","Number","_connect","connect","call","method","params","timeout","ws_opts","Promise","resolve","reject","Error","message","jsonrpc","id","promise","setTimeout","login","resp","listMethods","notify","subscribe","result","unsubscribe","setAutoReconnect","setReconnectInterval","interval","setMaxReconnects","getCurrentReconnects","getMaxReconnects","isReconnecting","willReconnect","clearTimeout","ArrayBuffer","Buffer","from","toString","notification","listeners","length","Object","keys","args","push","i","then","apply","Client"],"sources":["/Users/astrix_05/solana-private-vote/app/node_modules/rpc-websockets/src/lib/client/websocket.browser.ts","/Users/astrix_05/solana-private-vote/app/node_modules/rpc-websockets/src/lib/utils.ts","/Users/astrix_05/solana-private-vote/app/node_modules/rpc-websockets/src/lib/client.ts","/Users/astrix_05/solana-private-vote/app/node_modules/rpc-websockets/src/index.browser.ts"],"sourcesContent":["/**\n * WebSocket implements a browser-side WebSocket specification.\n * @module Client\n */\n\n\"use strict\"\n\nimport { EventEmitter } from \"eventemitter3\"\n\nimport {\n    BrowserWebSocketType,\n    NodeWebSocketType,\n    IWSClientAdditionalOptions,\n} from \"./client.types.js\"\n\nclass WebSocketBrowserImpl extends EventEmitter\n{\n    socket: BrowserWebSocketType\n\n    /** Instantiate a WebSocket class\n   * @constructor\n   * @param {String} address - url to a websocket server\n   * @param {(Object)} options - websocket options\n   * @param {(String|Array)} protocols - a list of protocols\n   * @return {WebSocketBrowserImpl} - returns a WebSocket instance\n   */\n    constructor(address: string, options: {}, protocols?: string | string[])\n    {\n        super()\n\n        this.socket = new window.WebSocket(address, protocols)\n\n        this.socket.onopen = () => this.emit(\"open\")\n        this.socket.onmessage = (event) => this.emit(\"message\", event.data)\n        this.socket.onerror = (error) => this.emit(\"error\", error)\n        this.socket.onclose = (event) =>\n        {\n            this.emit(\"close\", event.code, event.reason)\n        }\n    }\n\n    /**\n   * Sends data through a websocket connection\n   * @method\n   * @param {(String|Object)} data - data to be sent via websocket\n   * @param {Object} optionsOrCallback - ws options\n   * @param {Function} callback - a callback called once the data is sent\n   * @return {Undefined}\n   */\n    send(\n        data: Parameters<BrowserWebSocketType[\"send\"]>[0],\n        optionsOrCallback: (\n      error?: Error\n    ) => void | Parameters<NodeWebSocketType[\"send\"]>[1],\n        callback?: () => void\n    )\n    {\n        const cb = callback || optionsOrCallback\n\n        try\n        {\n            this.socket.send(data)\n            cb()\n        }\n        catch (error)\n        {\n            cb(error)\n        }\n    }\n\n    /**\n   * Closes an underlying socket\n   * @method\n   * @param {Number} code - status code explaining why the connection is being closed\n   * @param {String} reason - a description why the connection is closing\n   * @return {Undefined}\n   * @throws {Error}\n   */\n    close(code?: number, reason?: string)\n    {\n        this.socket.close(code, reason)\n    }\n\n    addEventListener<K extends keyof WebSocketEventMap>(\n        type: K,\n        listener: (ev: WebSocketEventMap[K]) => any,\n        options?: boolean | AddEventListenerOptions\n    ): void\n    {\n        this.socket.addEventListener(type, listener, options)\n    }\n}\n\n/**\n * factory method for common WebSocket instance\n * @method\n * @param {String} address - url to a websocket server\n * @param {(Object)} options - websocket options\n * @return {Undefined}\n */\nexport function WebSocket(\n    address: string,\n    options: IWSClientAdditionalOptions\n)\n{\n    return new WebSocketBrowserImpl(address, options)\n}\n","\"use strict\"\n\nexport interface DataPack<\n  T,\n  R extends string | ArrayBufferLike | Blob | ArrayBufferView\n> {\n  encode(value: T): R;\n  decode(value: R): T;\n}\n\nexport class DefaultDataPack implements DataPack<Object, string>\n{\n    encode(value: Object): string\n    {\n        return JSON.stringify(value)\n    }\n\n    decode(value: string): Object\n    {\n        return JSON.parse(value)\n    }\n}\n","/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\n\"use strict\"\n\nimport NodeWebSocket from \"ws\"\nimport { EventEmitter } from \"eventemitter3\"\nimport {\n    ICommonWebSocket,\n    IWSClientAdditionalOptions,\n    NodeWebSocketType,\n    ICommonWebSocketFactory,\n} from \"./client/client.types.js\"\n\nimport { DataPack, DefaultDataPack } from \"./utils.js\"\n\ninterface IQueueElement {\n  promise: [\n    Parameters<ConstructorParameters<typeof Promise>[0]>[0],\n    Parameters<ConstructorParameters<typeof Promise>[0]>[1]\n  ];\n  timeout?: ReturnType<typeof setTimeout>;\n}\n\nexport interface IQueue {\n  [x: number | string]: IQueueElement;\n}\n\nexport interface IWSRequestParams {\n  [x: string]: any;\n  [x: number]: any;\n}\n\nexport class CommonClient extends EventEmitter\n{\n    private address: string\n    private rpc_id: number | string\n    private queue: IQueue\n    private options: IWSClientAdditionalOptions & NodeWebSocket.ClientOptions\n    private autoconnect: boolean\n    private ready: boolean\n    private reconnect: boolean\n    private reconnect_timer_id: NodeJS.Timeout\n    private reconnect_interval: number\n    private max_reconnects: number\n    private rest_options: IWSClientAdditionalOptions &\n    NodeWebSocket.ClientOptions\n    private current_reconnects: number\n    private generate_request_id: (\n    method: string,\n    params: object | Array<any>\n  ) => number | string\n    private socket: ICommonWebSocket\n    private webSocketFactory: ICommonWebSocketFactory\n    private dataPack: DataPack<object, string>\n\n    /**\n   * Instantiate a Client class.\n   * @constructor\n   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n   * @param {String} address - url to a websocket server\n   * @param {Object} options - ws options object with reconnect parameters\n   * @param {Function} generate_request_id - custom generation request Id\n   * @param {DataPack} dataPack - data pack contains encoder and decoder\n   * @return {CommonClient}\n   */\n    constructor(\n        webSocketFactory: ICommonWebSocketFactory,\n        address = \"ws://localhost:8080\",\n        {\n            autoconnect = true,\n            reconnect = true,\n            reconnect_interval = 1000,\n            max_reconnects = 5,\n            ...rest_options\n        } = {},\n        generate_request_id?: (\n      method: string,\n      params: object | Array<any>\n    ) => number | string,\n        dataPack?: DataPack<object, string>\n    )\n    {\n        super()\n\n        this.webSocketFactory = webSocketFactory\n\n        this.queue = {}\n        this.rpc_id = 0\n\n        this.address = address\n        this.autoconnect = autoconnect\n        this.ready = false\n        this.reconnect = reconnect\n        this.reconnect_timer_id = undefined\n        this.reconnect_interval = reconnect_interval\n        this.max_reconnects = max_reconnects\n        this.rest_options = rest_options\n        this.current_reconnects = 0\n        this.generate_request_id = generate_request_id || (() => typeof this.rpc_id === \"number\"\n            ? ++this.rpc_id\n            : Number(this.rpc_id) + 1)\n\n        if (!dataPack) this.dataPack = new DefaultDataPack()\n        else this.dataPack = dataPack\n\n        if (this.autoconnect)\n            this._connect(this.address, {\n                autoconnect: this.autoconnect,\n                reconnect: this.reconnect,\n                reconnect_interval: this.reconnect_interval,\n                max_reconnects: this.max_reconnects,\n                ...this.rest_options,\n            })\n    }\n\n    /**\n   * Connects to a defined server if not connected already.\n   * @method\n   * @return {Undefined}\n   */\n    connect()\n    {\n        if (this.socket) return\n\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options,\n        })\n    }\n\n    /**\n   * Calls a registered RPC method on server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object|Array} params - optional method parameters\n   * @param {Number} timeout - RPC reply timeout value\n   * @param {Object} ws_opts - options passed to ws\n   * @return {Promise}\n   */\n    call(\n        method: string,\n        params?: IWSRequestParams,\n        timeout?: number,\n        ws_opts?: Parameters<NodeWebSocketType[\"send\"]>[1]\n    )\n    {\n        if (!ws_opts && \"object\" === typeof timeout)\n        {\n            ws_opts = timeout\n            timeout = null\n        }\n\n        return new Promise((resolve, reject) =>\n        {\n            if (!this.ready) return reject(new Error(\"socket not ready\"))\n\n            const rpc_id = this.generate_request_id(method, params)\n\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params: params || undefined,\n                id: rpc_id,\n            }\n\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error) =>\n            {\n                if (error) return reject(error)\n\n                this.queue[rpc_id] = { promise: [resolve, reject] }\n\n                if (timeout)\n                {\n                    this.queue[rpc_id].timeout = setTimeout(() =>\n                    {\n                        delete this.queue[rpc_id]\n                        reject(new Error(\"reply timeout\"))\n                    }, timeout)\n                }\n            })\n        })\n    }\n\n    /**\n   * Logins with the other side of the connection.\n   * @method\n   * @param {Object} params - Login credentials object\n   * @return {Promise}\n   */\n    async login(params: IWSRequestParams)\n    {\n        const resp = await this.call(\"rpc.login\", params)\n\n        if (!resp) throw new Error(\"authentication failed\")\n\n        return resp\n    }\n\n    /**\n   * Fetches a list of client's methods registered on server.\n   * @method\n   * @return {Array}\n   */\n    async listMethods()\n    {\n        return await this.call(\"__listMethods\")\n    }\n\n    /**\n   * Sends a JSON-RPC 2.0 notification to server.\n   * @method\n   * @param {String} method - RPC method name\n   * @param {Object} params - optional method parameters\n   * @return {Promise}\n   */\n    notify(method: string, params?: IWSRequestParams)\n    {\n        return new Promise<void>((resolve, reject) =>\n        {\n            if (!this.ready) return reject(new Error(\"socket not ready\"))\n\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params,\n            }\n\n            this.socket.send(this.dataPack.encode(message), (error) =>\n            {\n                if (error) return reject(error)\n\n                resolve()\n            })\n        })\n    }\n\n    /**\n   * Subscribes for a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n    async subscribe(event: string | Array<string>)\n    {\n        if (typeof event === \"string\") event = [event]\n\n        const result = await this.call(\"rpc.on\", event)\n\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\n                \"Failed subscribing to an event '\" + event + \"' with: \" + result[event]\n            )\n\n        return result\n    }\n\n    /**\n   * Unsubscribes from a defined event.\n   * @method\n   * @param {String|Array} event - event name\n   * @return {Undefined}\n   * @throws {Error}\n   */\n    async unsubscribe(event: string | Array<string>)\n    {\n        if (typeof event === \"string\") event = [event]\n\n        const result = await this.call(\"rpc.off\", event)\n\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed unsubscribing from an event with: \" + result)\n\n        return result\n    }\n\n    /**\n   * Closes a WebSocket connection gracefully.\n   * @method\n   * @param {Number} code - socket close code\n   * @param {String} data - optional data to be sent before closing\n   * @return {Undefined}\n   */\n    close(code?: number, data?: string)\n    {\n        if (this.socket) this.socket.close(code || 1000, data)\n    }\n\n    /**\n   * Enable / disable automatic reconnection.\n   * @method\n   * @param {Boolean} reconnect - enable / disable reconnection\n   * @return {Undefined}\n   */\n    setAutoReconnect(reconnect: boolean)\n    {\n        this.reconnect = reconnect\n    }\n\n    /**\n   * Set the interval between reconnection attempts.\n   * @method\n   * @param {Number} interval - reconnection interval in milliseconds\n   * @return {Undefined}\n   */\n    setReconnectInterval(interval: number)\n    {\n        this.reconnect_interval = interval\n    }\n\n    /**\n   * Set the maximum number of reconnection attempts.\n   * @method\n   * @param {Number} max_reconnects - maximum reconnection attempts\n   * @return {Undefined}\n   */\n    setMaxReconnects(max_reconnects: number)\n    {\n        this.max_reconnects = max_reconnects\n    }\n\n    /**\n   * Get the current number of reconnection attempts made.\n   * @method\n   * @return {Number} current reconnection attempts\n   */\n    getCurrentReconnects()\n    {\n        return this.current_reconnects\n    }\n\n    /**\n   * Get the maximum number of reconnection attempts.\n   * @method\n   * @return {Number} maximum reconnection attempts\n   */\n    getMaxReconnects()\n    {\n        return this.max_reconnects\n    }\n\n    /**\n   * Check if the client is currently attempting to reconnect.\n   * @method\n   * @return {Boolean} true if reconnection is in progress\n   */\n    isReconnecting()\n    {\n        return this.reconnect_timer_id !== undefined\n    }\n\n    /**\n   * Check if the client will attempt to reconnect on the next close event.\n   * @method\n   * @return {Boolean} true if reconnection will be attempted\n   */\n    willReconnect()\n    {\n        return this.reconnect &&\n            (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects)\n    }\n\n    /**\n   * Connection/Message handler.\n   * @method\n   * @private\n   * @param {String} address - WebSocket API address\n   * @param {Object} options - ws options object\n   * @return {Undefined}\n   */\n    private _connect(\n        address: string,\n        options: IWSClientAdditionalOptions & NodeWebSocket.ClientOptions\n    )\n    {\n        clearTimeout(this.reconnect_timer_id)\n        this.socket = this.webSocketFactory(address, options)\n\n        this.socket.addEventListener(\"open\", () =>\n        {\n            this.ready = true\n            this.emit(\"open\")\n            this.current_reconnects = 0\n        })\n\n        this.socket.addEventListener(\"message\", ({ data: message }) =>\n        {\n            if (message instanceof ArrayBuffer)\n                message = Buffer.from(message).toString()\n\n            try\n            {\n                message = this.dataPack.decode(message)\n            }\n            catch (error)\n            {\n                return\n            }\n\n            // check if any listeners are attached and forward event\n            if (message.notification && this.listeners(message.notification).length)\n            {\n                if (!Object.keys(message.params).length)\n                    return this.emit(message.notification)\n\n                const args = [message.notification]\n\n                if (message.params.constructor === Object) args.push(message.params)\n                // using for-loop instead of unshift/spread because performance is better\n                else\n                    for (let i = 0; i < message.params.length; i++)\n                        args.push(message.params[i])\n\n                // run as microtask so that pending queue messages are resolved first\n                // eslint-disable-next-line prefer-spread\n                return Promise.resolve().then(() =>\n                {\n                    // eslint-disable-next-line prefer-spread\n                    this.emit.apply(this, args)\n                })\n            }\n\n            if (!this.queue[message.id])\n            {\n                // general JSON RPC 2.0 events\n                if (message.method)\n                {\n                    // run as microtask so that pending queue messages are resolved first\n                    return Promise.resolve().then(() =>\n                    {\n                        this.emit(message.method, message?.params)\n                    })\n                }\n\n                return\n            }\n\n            // reject early since server's response is invalid\n            if (\"error\" in message === \"result\" in message)\n                this.queue[message.id].promise[1](\n                    new Error(\n                        \"Server response malformed. Response must include either \\\"result\\\"\" +\n              \" or \\\"error\\\", but not both.\"\n                    )\n                )\n\n            if (this.queue[message.id].timeout)\n                clearTimeout(this.queue[message.id].timeout)\n\n            if (message.error) this.queue[message.id].promise[1](message.error)\n            else this.queue[message.id].promise[0](message.result)\n\n            delete this.queue[message.id]\n        })\n\n        this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error))\n\n        this.socket.addEventListener(\"close\", ({ code, reason }) =>\n        {\n            if (this.ready)\n            // Delay close event until internal state is updated\n                setTimeout(() => this.emit(\"close\", code, reason), 0)\n\n            this.ready = false\n            this.socket = undefined\n\n            if (code === 1000) return\n\n            this.current_reconnects++\n\n            if (\n                this.reconnect &&\n        (this.max_reconnects > this.current_reconnects ||\n          this.max_reconnects === 0)\n            )\n                this.reconnect_timer_id = setTimeout(\n                    () => this._connect(address, options),\n                    this.reconnect_interval\n                )\n            else if (this.reconnect && this.max_reconnects > 0 &&\n                this.current_reconnects >= this.max_reconnects)\n            {\n                // Emit event when max reconnects reached, after close event\n                setTimeout(() => this.emit(\"max_reconnects_reached\", code, reason), 1)\n            }\n        })\n    }\n}\n","\"use strict\"\n\nimport { WebSocket } from \"./lib/client/websocket.browser.js\"\nimport { CommonClient } from \"./lib/client.js\"\nimport { IWSClientAdditionalOptions } from \"./lib/client/client.types.js\"\n\nexport class Client extends CommonClient\n{\n    constructor(\n        address = \"ws://localhost:8080\",\n        {\n            autoconnect = true,\n            reconnect = true,\n            reconnect_interval = 1000,\n            max_reconnects = 5,\n        }: IWSClientAdditionalOptions = {},\n        generate_request_id?: (\n      method: string,\n      params: object | Array<any>\n    ) => number | string\n    )\n    {\n        super(\n            WebSocket,\n            address,\n            {\n                autoconnect,\n                reconnect,\n                reconnect_interval,\n                max_reconnects,\n            },\n            generate_request_id\n        )\n    }\n}\n\nexport * from \"./lib/client.js\"\nexport * from \"./lib/client/websocket.browser.js\"\nexport * from \"./lib/client/client.types.js\"\nexport * from \"./lib/utils.js\"\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}